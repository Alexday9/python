# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16qXtLYg7FVWHF0KVlagkoodJ1MyxdJl7
"""

def polynome(x):
  return (x**3)-1.5*(x**2)-6*x+5 # retourne la fonction 
polynome(5)

def factoriel(z):
  if(z!=0):
      i=1 # variable de depart pour elaborer le bon nombre de tour 
      c=1 # variable pour retourner et implementer le resultat
      while(i<=z):
          c = c*i
          i = i+1
      return c
  else :
    return 1 # retourne 1 si la valeur saisi est 0

factoriel(7)

def suite_fibonnaci():
  print("Entrer un nombre: ")
  x = input()
  i = 1
  c = 1
  cpt = 0
  print("La suite de fibonnaci est : ")
  print(end = "0, 1 ,")
  while(cpt < int(x) - 2):
    print(c, end= " ,")
    i,c=c,c + i
    cpt = cpt +1

suite_fibonnaci()

def poly_exeption(x):
  if(type(x)!= int):   # si le chiffre ou nombre rentrer n'est pas un int ( donc : complexe, str,...)
    if(type(x)==float): # si c'est un float
        if(x < 0.000001): # si le float n'est pas trop petit
          print("Veuillez entrer un chiffre plus grand !")
          return
        elif(x> 10000) : # si le float n'est pas trop grand
          print("Veuillez entrer un chiffre ou nombre plus petit !") 
          return
        else:
          return (x**3)-1.5*(x**2)-6*x+5
    print("Veuillez entrer un chiffre ou un nombre !")
    return
  elif(x < 0):   # si le chiffre ou nombre est nÃ©gatif
    print("Veuillez saisir un chiffre ou nombre positif !")
    return
  elif(x > 10000): # si le chiffre ou nombre est trop grand ,   
    print("Veuillez entrer un chiffre ou nombre plus petit !") 
    return 
  else :
    return (x**3)-1.5*(x**2)-6*x+5

poly_exeption(100000.1119)

poly_exeption(0.002)

poly_exeption("2")

poly_exeption(2+4j)

poly_exeption("ererer")

import numpy as np

def Mod_Black_Scholes_merton(S,X,T,r,sig): 
  
  d1 = (np.log(S/X)+(r+((sig**2)/2))*T)/(sig*(np.sqrt(T)))
  d2 = (np.log(S/X)+(r-(((sig**2)/2))*T))/(sig*(np.sqrt(T)))

  c = S*d1-(X*np.exp(-r*T))*d2
  p = X*np.exp(-r*T)*(-d2)-(S*(-d1))

  z = { "Call_Option" : c, "Call_Price" : p}
  return z

Mod_Black_Scholes_merton(100,20,15,4,0.20)